#+TITLE:git 常用bash命令
#+AUTHOR:ALIANG
#+EMAIL:anbgsl1110@gmail.com
#+KEYWORDS:DIARY
【aliang diary】-青春无限可能，拎得清，爱生活，爱自己

-日期：2016-07-12；作者：阿亮；关键字：笔记、git、bash
* git 常用bash命令
** 远程仓库相关命令
****** 检出仓库
#+BEGIN_SRC bash
$ git clone git://github.com/xx/xx.git
#+END_SRC
****** 检出仓库
#+BEGIN_SRC bash
$ git clone -o github -b 2.0.0 git://github.com/xx/xx.git xx2
#+END_SRC
直接检出分支 2.0.0，指定远程仓库名称为 github （默认为 origin）、检出到文件夹 xx2 (默认为 xx)
****** 查看远程仓库
#+BEGIN_SRC bash
$ git remote -v
#+END_SRC
****** 添加远程仓库
#+BEGIN_SRC bash
$ git remote add [name] [url]
#+END_SRC
****** 删除远程仓库
#+BEGIN_SRC bash
$ git remote rm [name]
#+END_SRC
****** 修改远程仓库
#+BEGIN_SRC bash
$ git remote set-url --push [name] [newUrl]
#+END_SRC
****** 拉取远程仓库
#+BEGIN_SRC bash
$ git pull [remoteName] [localBranchName]
#+END_SRC
****** 推送远程仓库
#+BEGIN_SRC bash
$ git push [remoteName] [localBranchName]
#+END_SRC
****** 强制推送更改
#+BEGIN_SRC bash
$ git push --force origin master
#+END_SRC
如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：
#+BEGIN_SRC org
$ git push origin test:master         // 提交本地test分支作为远程的master分支
$ git push origin test:test           // 提交本地test分支作为远程的test分支
#+END_SRC
** 分支(branch)操作相关命令
****** 查看本地分支
#+BEGIN_SRC bash
$ git branch
#+END_SRC
****** 查看远程分支
#+BEGIN_SRC bash
$ git branch -r
#+END_SRC
如果还是看不到就先 git fetch origin
****** 先创建本地分支
#+BEGIN_SRC bash
$ git branch [name]
#+END_SRC
注意新分支创建后不会自动切换为当前分支
****** 切换分支
#+BEGIN_SRC bash
$ git checkout [name]
#+END_SRC
****** 创建新分支并立即切换到新分支
#+BEGIN_SRC bash
$ git checkout -b [name]
#+END_SRC
****** 直接检出远程分支
#+BEGIN_SRC org
$ git checkout -b [name] [remoteName] (如：git checkout -b myNewBranch origin/dragon)
#+END_SRC
****** 删除分支
#+BEGIN_SRC git
$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项
#+END_SRC
****** 合并分支
#+BEGIN_SRC git
$ git merge [name]
#+END_SRC
将名称为[name]的分支与当前分支合并
****** 合并最后的2个提交
#+BEGIN_SRC git
$ git rebase -i HEAD~2
#+END_SRC
数字2按需修改即可（如果需提交到远端
#+BEGIN_SRC git
$ git push -f origin master
#+END_SRC
慎用）
****** 创建远程分支(本地分支push到远程)
#+BEGIN_SRC git
$ git push origin [name]
#+END_SRC
****** 删除远程分支
#+BEGIN_SRC git
$ git push origin :heads/[name] 或 $ git push origin :[name]
#+END_SRC
****** 修改本地分支名称
#+BEGIN_SRC git
git branch -m <old_branch_name> <new_branch_name>
#+END_SRC
****** 直接修改远程分支名称(不修改本地的)
#+BEGIN_SRC git
git push <remote> <remote>/<old_name>:refs/heads/<new_name> :<old_name>
#+END_SRC
****** 修改本地及其远程分支的名称
#+BEGIN_SRC git
        1. git branch -m <old_name> <new_name>
        2. git push <remote> --set-upstream new_name
        3. git push <remote> :old_name
        4. git fetch <remote>
        5. git remote prune <remote>
#+END_SRC
** 创建空的分支
执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔
****** 方法1
#+BEGIN_SRC git
$ git checkout --orphan <branch_name>
$ git rm -rf *
#+END_SRC
****** 方法2
#+BEGIN_SRC git
$ git symbolic-ref HEAD refs/heads/[name]
$ rm .git/index
$ git clean -fdx
#+END_SRC
** 版本(tag)操作相关命令
****** 查看版本
#+BEGIN_SRC git
$ git tag
#+END_SRC
****** 创建版本
#+BEGIN_SRC git
$ git tag [name]
#+END_SRC
****** 删除版本
#+BEGIN_SRC git
$ git tag -d [name]
#+END_SRC
****** 查看远程版本
#+BEGIN_SRC git
$ git tag -r
#+END_SRC
****** 创建远程版本(本地版本push到远程)
#+BEGIN_SRC git
$ git push origin [name]
#+END_SRC
****** 删除远程版本
#+BEGIN_SRC git
$ git push origin :refs/tags/[name]
#+END_SRC
****** 合并远程仓库的tag到本地
#+BEGIN_SRC git
$ git pull origin --tags
#+END_SRC
****** 上传本地tag到远程仓库
#+BEGIN_SRC git
$ git push origin --tags
#+END_SRC
****** 创建带注释的tag
#+BEGIN_SRC git
$ git tag -a [name] -m 'yourMessage'
#+END_SRC
** 子模块(submodule)相关操作命令
****** 添加子模块
#+BEGIN_SRC git
$ git submodule add [url] [path]
#+END_SRC
如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs
****** 初始化子模块
#+BEGIN_SRC git
$ git submodule init  ----只在首次检出仓库时运行一次就行
#+END_SRC
****** 更新子模块
#+BEGIN_SRC git
$ git submodule update ----每次更新或切换分支后都需要运行一下
#+END_SRC
****** 删除子模块（分4步走哦）
#+BEGIN_SRC git
1) $ git rm --cached [path]
2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉
3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉
4) 手动删除子模块残留的目录
#+END_SRC
** 忽略一些文件、文件夹不提交
#+BEGIN_SRC git
在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如
target
bin
*.db
#+END_SRC
** 回退
****** 删除当前仓库内未受版本管理的文件
#+BEGIN_SRC git
$ git clean -f
#+END_SRC
****** 恢复仓库到上一次的提交状态
#+BEGIN_SRC git
$ git reset --hard
#+END_SRC
****** 回退所有内容到上一个版本
#+BEGIN_SRC git
$ git reset HEAD^
#+END_SRC
****** 回退a.py这个文件的版本到上一个版本
#+BEGIN_SRC git
$ git reset HEAD^ a.py
#+END_SRC
****** 回退到某个版本
#+BEGIN_SRC git
$ git reset 057d
#+END_SRC
****** 将本地的状态回退到和远程的一样
#+BEGIN_SRC git
$ git reset –hard origin/master
#+END_SRC
****** 向前回退到第3个版本
#+BEGIN_SRC git
$ git reset –soft HEAD~3
#+END_SRC
****** 修改最后的提交日志
#+BEGIN_SRC git
$ git commit --amend
#+END_SRC
****** 修改最后的提交日期为当前时间
#+BEGIN_SRC git
$ git commit --amend  --date="$(date -R)"
#+END_SRC
** Git一键推送多个远程仓库
****** 编辑本地仓库的.git/config文件
#+BEGIN_SRC git
[remote "all"]
url = git@github.com:dragon/test.git
url = git@gitcafe.com:dragon/test.git
#+END_SRC
这样，使用git push all即可一键Push到多个远程仓库中。

** 缓存认证信息
#+BEGIN_SRC git
$ git config credential.helper cache
#+END_SRC
** 查看提交日志
》查看文件中的每一行的作者、最新的变更提交和提交时间
#+BEGIN_SRC git
$ git blame [fileName]
#+END_SRC
****** Git常用操作命令
- rongjih
****** 查看仓库历史记录
有三个应该知道的选项。
#+BEGIN_SRC git
- oneline -压缩模式，在每个提交的旁边显示经过精简的提交哈希码和提交信息，以一行显示。
- graph -图形模式，使用该选项会在输出的左边绘制一张基于文本格式的历史信息表示图。如果你查看的是单个分支的历史记录的话，该选项无效。
- all -显示所有分支的历史记录
#+END_SRC
****** 把这些选项组合起来之后如下
#+BEGIN_SRC git
 $ git log --oneline --graph
#+END_SRC
--name-status 既可以看到简介的日志信息，也可以看到改了哪些文件，一举两得：
** 有选择的合并 - 这个功能最赞，没有之一
cherry-pick 可以从不同的分支中捡出一个单独的commit，并把它和你当前的分支合并。如果你以并行方式在处理两个或以上分支，你可能会发现一个在全部分支中都有的bug。如果你在一个分支中解决了它，你可以使用cherry-pick命令把它commit到其它分支上去，而不会弄乱其他的文件或commit。
#+BEGIN_SRC git
$ git cherry-pick [commitHash]
#+END_SRC
** Stash未提交的更改
正在修改某个bug或者某个特性，又突然被要求展示工作。而现在所做的工作还不足以提交，这个阶段还无法进行展示（不能回到更改之前）。在这种情况下， git stash可以帮到忙了。stash在本质上会取走所有的变更并存储它们以备将来使用。
#+BEGIN_SRC git
$ git stash
#+END_SRC
检查stash列表：
#+BEGIN_SRC git
$ git stash list
#+END_SRC
想解除stash并且恢复未提交的变更，就进行apply stash：
#+BEGIN_SRC git
$ git stash apply
#+END_SRC
如果只想留有余地进行apply stash，给apply添加特定的标识符：
#+BEGIN_SRC git
$ git stash apply stash@{0}
#+END_SRC
** 多次修改后拆分提交 - 暂存文件的部分改动
一般情况下，创建一个基于特性的提交是比较好的做法，意思是每次提交都必须代表一个新特性的产生或者是一个bug的修复。如果你修复了两个bug，或是添加了多个新特性但是却没有提交这些变化会怎样呢？在这种情况下，你可以把这些变化放在一次提交中。但更好的方法是把文件暂存(Stage)然后分别提交。
例如你对一个文件进行了多次修改并且想把他们分别提交。这种情况下，可以在 add 命令中加上 -p 参数
#+BEGIN_SRC git
$ git add -p [fileName]
#+END_SRC
** 压缩多个Commit
用rebase命令把多个commit压缩成一个
#+BEGIN_SRC org
git rebase -i HEAD~[number_of_commits]
#+END_SRC
如果你想要压缩最后两个commit，你需要运行下列命令：
#+BEGIN_SRC org
git rebase -i HEAD~2
#+END_SRC
Docs: 7.6 Git 工具 - 重写历史 、3.6 Git 分支 - 变基
** 差异查看
#+BEGIN_SRC org
$ git diff --name-status HEAD~2 HEAD~3 <-- 获得两个版本间所有变更的文件列表
$ git diff HEAD HEAD~1 <-- 查看最近两个提交之间的差异
$ git diff HEAD HEAD~2 <-- 查看第1个与第3个提交之间的差异
$ ^ - 代表父提交，^n 表示第n个父提交，^相当于^1 git寻根：^和~的区别 - 分析得很到位
$ ~ - 代表连续的提交，~n相当于连续的第n个提交
$ git diff master..test <-- 比较两个分支之间的差异
$ git diff master...test <-- 比较master、test的共有父分支和 test 分支之间的差异
$ git diff test <-- 比较当前工作目录与 test 分支的差异
$ git diff HEAD <-- 比较当前工作目录与上次提交的差异
$ git diff HEAD -- ./lib  <-- 比较当前工作目录下的lib目录与上次提交的差异
$ git diff --stat  <-- 统计一下有哪些文件被改动，有多少行被改动
$ git diff --cached  <-- 查看下次提交时要提交的内容(staged,添加到索引中)
#+END_SRC
